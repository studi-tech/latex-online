events {}

http {
  # Internal back-ends
  upstream api     { server app:2700; }
  upstream metabase { server metabase:3000; }

  # Optional: nicer websocket upgrade handling
  map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
  }

  server {
    listen 80;

    #
    # 1. Metabase under /metabase/
    #
    location /metabase/ {
      # strip the prefix before proxying
      proxy_pass http://metabase/;
      # ---- essentials ----
      proxy_set_header Host              $host;
      proxy_set_header X-Real-IP         $remote_addr;
      proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
      # websockets/streaming
      proxy_set_header Upgrade           $http_upgrade;
      proxy_set_header Connection        "upgrade";
    }

    #
    # 2. PDF renderer under /latexonline/
    #
    location /latexonline/ {
      client_max_body_size 100M;

      proxy_pass http://api;
      proxy_http_version 1.1;

      proxy_set_header Host            $host;
      proxy_set_header X-Real-IP       $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      proxy_set_header Upgrade         $http_upgrade;
      proxy_set_header Connection      $connection_upgrade;

      
      # Give the upstream plenty of time to generate the PDF
      proxy_connect_timeout  300s;  # connect to upstream
      proxy_send_timeout     300s;  # send request to upstream
      proxy_read_timeout     900s;  # wait for response from upstream

      # Make sure the client connection doesn't idle out while sending
      send_timeout           900s;

      # Stream instead of buffering to temp files (optional but helpful for large PDFs)
      proxy_buffering        off;
      proxy_request_buffering off;
      # If you want to explicitly tell upstream proxies not to buffer:
      add_header X-Accel-Buffering no;
    }

    
    #
    # 3. Default: simple 200 OK for everything else
    #
    location / {
      default_type text/plain;
      return 200 "OK\n";
    }
  }
}
